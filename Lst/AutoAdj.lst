C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE AUTOADJ
OBJECT MODULE PLACED IN .\Bin\AutoAdj.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Lib\AutoAdj.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\App;.\App\OSD;.\App\U
                    -ser;.\Lib;.\Lib\NT68655_770_850 Series;.\Lib\ScalerCfg;.\Phy\Panel;.\Phy\SI\NVT\Board;.\Phy\SI\NVT\Component;.\Phy\SI\NV
                    -T\Keypad;.\Sys;.\Sys\SI\NVT;.\Phy\SI\NVT\Keypad\NT68857_MODULE_KEYPAD) DEFINE(SCALER_TYPE=NT68857,NT68857_MODULE,NVT_192
                    -0X1080,FLASH_BANK=4) PRINT(.\Lst\AutoAdj.lst) OBJECT(.\Bin\AutoAdj.obj)

line level    source

   1          /******************************************************************************/
   2          /*                       Novatek MicroElectronics Corp.                       */
   3          /*       6F, No. 1-2, Innovation Road I, Science-Based Industrial Park,       */
   4          /*                         HsinChu 300, Taiwan, R.O.C.                        */
   5          /*                 TEL:886-3-567-0889       FAX:886-3-577-0132                */
   6          /*                            All Rights Reserved                             */
   7          /******************************************************************************/
   8          
   9          //******************************************************************************
  10          // I N C L U D E   F I L E S
  11          //******************************************************************************
  12          #include "Include.h"
*** WARNING C318 IN LINE 254 OF .\SYS\SI\NVT\MODELCFG.H: can't open file 'NT68857_MODULE\ModelConfig.h'
*** WARNING C318 IN LINE 255 OF .\SYS\SI\NVT\MODELCFG.H: can't open file 'NT68857_MODULE\GlobalTimerDef.h'
*** WARNING C318 IN LINE 256 OF .\SYS\SI\NVT\MODELCFG.H: can't open file 'NT68857_MODULE\NonSupportTimingList.h'
*** WARNING C318 IN LINE 257 OF .\SYS\SI\NVT\MODELCFG.H: can't open file 'NT68857_MODULE\OSDConfig.h'
*** WARNING C318 IN LINE 258 OF .\SYS\SI\NVT\MODELCFG.H: can't open file 'NT68857_MODULE\SRConfig.h'
*** WARNING C322 IN LINE 11 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 11 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 15 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 26 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 33 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 33 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 33 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 40 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 47 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 54 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 61 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 68 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 75 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 82 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 89 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 96 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 103 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 110 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 2   

             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 117 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 124 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 131 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 140 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 147 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 154 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 161 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 168 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 175 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 187 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 194 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 201 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 208 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 215 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 222 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 229 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 236 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 243 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 250 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 259 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 266 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 273 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 280 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 287 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 294 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 301 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 308 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 315 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 322 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 329 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 336 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 3   

             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 343 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 350 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 360 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 367 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 374 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 381 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 388 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 395 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 402 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 409 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 419 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 426 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 438 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 442 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 452 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 460 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURC
             -ECODE\SYS\SI\NVT\MODELVERIFICATION.H: unknown identifier
*** WARNING C322 IN LINE 17 OF .\PHY\SI\NVT\BOARD\BOARD.H: unknown identifier
*** WARNING C318 IN LINE 18 OF .\PHY\SI\NVT\BOARD\BOARD.H: can't open file 'NT68168_DEMO_BOARD\BoardConfig.h'
*** WARNING C322 IN LINE 11 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\PHY\SI\NVT\BOARD\BOARDVERIFY.H: unknown identifier
*** WARNING C322 IN LINE 11 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\PHY\SI\NVT\BOARD\BOARDVERIFY.H: unknown identifier
*** ERROR C202 IN LINE 74 OF LIB\INT.H: 'UART_TX_BUFFER_SIZE': undefined identifier
*** ERROR C136 IN LINE 74 OF LIB\INT.H: invalid dimension size: [0]
*** ERROR C202 IN LINE 75 OF LIB\INT.H: 'UART_RX_BUFFER_SIZE': undefined identifier
*** ERROR C136 IN LINE 75 OF LIB\INT.H: invalid dimension size: [0]
*** WARNING C322 IN LINE 127 OF LIB\INT.H: unknown identifier
*** WARNING C322 IN LINE 127 OF LIB\INT.H: unknown identifier
*** WARNING C322 IN LINE 127 OF LIB\INT.H: unknown identifier
*** WARNING C322 IN LINE 127 OF LIB\INT.H: unknown identifier
*** WARNING C322 IN LINE 132 OF LIB\INT.H: unknown identifier
*** WARNING C322 IN LINE 132 OF LIB\INT.H: unknown identifier
*** WARNING C322 IN LINE 16 OF .\PHY\SI\NVT\KEYPAD\KEYPAD.H: unknown identifier
*** WARNING C318 IN LINE 17 OF .\PHY\SI\NVT\KEYPAD\KEYPAD.H: can't open file 'NT68168_DEMO_KEYPAD\KeyPadConfig.h'
*** WARNING C322 IN LINE 42 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\LIB\NT68655_770_850 SERIES\SCALER_POWER.H: unknown identifier
*** WARNING C322 IN LINE 36 OF \USERS\COBB.CHEN\DESKTOP\AD908\04_CODE_P6121_V100_160902-OK\CODE_P6121_V100_161116\SOURCE
             -CODE\LIB\NT68655_770_850 SERIES\SCALER_PWM.H: unknown identifier
*** WARNING C322 IN LINE 227 OF .\SYS\NVRAM.H: unknown identifier
*** WARNING C322 IN LINE 103 OF .\APP\OSD\OSDCTRL.H: unknown identifier
*** WARNING C322 IN LINE 168 OF .\APP\OSD\OSDCTRL.H: unknown identifier
*** WARNING C322 IN LINE 505 OF .\APP\OSD\OSDCTRL.H: unknown identifier
*** WARNING C322 IN LINE 97 OF .\APP\OSD\OSDINDEX.H: unknown identifier
*** WARNING C322 IN LINE 66 OF .\APP\OSD\OSDVIEW.H: unknown identifier
*** WARNING C322 IN LINE 148 OF .\APP\OSD\OSDVIEW.H: unknown identifier
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 4   

*** WARNING C322 IN LINE 320 OF .\APP\OSD\OSDVIEW.H: unknown identifier
*** WARNING C322 IN LINE 389 OF .\APP\OSD\OSDVIEW.H: unknown identifier
*** WARNING C322 IN LINE 475 OF .\APP\OSD\OSDVIEW.H: unknown identifier
*** ERROR C320 IN LINE 170 OF .\PHY\PANEL\PANEL.H: "Please choose one panel at least!"
*** WARNING C322 IN LINE 172 OF .\PHY\PANEL\PANEL.H: unknown identifier
*** WARNING C322 IN LINE 172 OF .\PHY\PANEL\PANEL.H: unknown identifier
*** WARNING C322 IN LINE 172 OF .\PHY\PANEL\PANEL.H: unknown identifier
*** WARNING C322 IN LINE 172 OF .\PHY\PANEL\PANEL.H: unknown identifier
*** ERROR C320 IN LINE 173 OF .\PHY\PANEL\PANEL.H: "Wrong PanelVTotal setting! Please review it!"
*** WARNING C322 IN LINE 56 OF .\SYS\SYNCHANDLER.H: unknown identifier
*** WARNING C322 IN LINE 56 OF .\SYS\SYNCHANDLER.H: unknown identifier
*** WARNING C322 IN LINE 47 OF .\SYS\SYSAPI.H: unknown identifier
*** WARNING C322 IN LINE 107 OF .\APP\INCLUDE.H: unknown identifier
*** WARNING C322 IN LINE 107 OF .\APP\INCLUDE.H: unknown identifier
*** WARNING C322 IN LINE 111 OF .\APP\INCLUDE.H: unknown identifier
  13          
  14          //******************************************************************************
  15          // M A C R O   D E F I N I T I O N S
  16          //******************************************************************************
  17          #define LOOP_COUNTER        10 /*!< Count of iteration of ADC gain/offset calibration. */
  18          #define ADC_GAIN_TOLERANCE   3 /*!< The tolerance of ADC gain calibration. */
  19          #define ADC_OFFSET_TOLERANCE 3 /*!< The tolerance of ADC offset calibration. */
  20          #define GetInputHActWid() (ReadShortScaler(&SC_GI_POS_HWID_LO) & 0x0FFF) /*!< Horizontal active pixel coun
             -t from scaler. */
  21          #define GetInputVActLen() (ReadShortScaler(&SC_GI_POS_VLEN_LO) & 0x07FF) /*!< Vertical active line count f
             -rom scaler. */
  22          #define GetInputHActBeg() (ReadShortScaler(&SC_GI_POS_HBEG_LO) & 0x0FFF) /*!< Horizontal start position co
             -unt from scaler. */
  23          #define GetInputVActBeg() (ReadShortScaler(&SC_GI_POS_VBEGO_LO) & 0x07FF) /*!< Vertical start position cou
             -nt from scaler. */
  24          
  25          //******************************************************************************
  26          // G L O B A L   V A R I A B L E S
  27          //******************************************************************************
  28          
  29          //******************************************************************************
  30          // S T A T I C   V A R I A B L E S
  31          //******************************************************************************
  32          static BOOL bAbortAutoTune; /*!< Flag of status of auto-tune. */
  33          static BOOL bIsNonFullScreen; /*!< Flag of status of full-screen. */
  34          static xdata UCHAR ucPhaseRange; /*!< The range of phase calibration. The value would be 16 or 32. */
  35          static xdata UCHAR ucPhaseIndexLo; /*!< Variable for auto-tune functions. */
  36          static xdata UCHAR ucPhaseIndexHi; /*!< Variable for auto-tune functions. */
  37          static xdata UCHAR ucAutoPct; /*!< Percentage of progress of auto-tune. */
  38          
  39          //******************************************************************************
  40          // E X T E R N A L   V A R I A B L E   P R O T O T Y P E S
  41          //******************************************************************************
  42          
  43          //******************************************************************************
  44          // S T A T I C   F U N C T I O N   P R O T O T Y P E S
  45          //******************************************************************************
  46          static void AutoTuneComplete(void);
  47          static ULONG CheckPhaseData(void);
  48          static BOOL AutoGainCoarse(void);
  49          static BOOL MeasureImageSize(void);
  50          static BOOL AutoClockByPhase(void);
  51          static void CheckImageOutOfScreen(void);
  52          
  53          //******************************************************************************
  54          // E X T E R N A L   F U N C T I O N   P R O T O T Y P E S
  55          //******************************************************************************
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 5   

  56          
  57          //******************************************************************************
  58          // F U N C T I O N   B O D Y S
  59          //******************************************************************************
  60          
  61          /**************************************************************************//**
  62           * Check we can perform auto-tune on the the current input interface or not.
  63           * @return TRUE if interface is valid else FALSE.
  64           ******************************************************************************/
  65          BOOL IsAutoTuneValid(void)
  66          {
  67   1          UCHAR interface = GetCurrInputInterface();
  68   1      
  69   1          if ((interface == DIGITAL_INPUT0) || (interface == DIGITAL_INPUT1) || (interface == DISPLAY_PORT_INPUT
             -)) {
  70   2              return FALSE;
  71   2          }
  72   1          return TRUE;
  73   1      }
  74          
  75          /**************************************************************************//**
  76           * Automatically find H/V start position, input clock and ADC phase
  77           * @return TRUE if auto-tune is succeeded else FALSE.
  78           ******************************************************************************/
  79          BOOL AutoTune(void)
  80          {
  81   1          UCHAR reg_bak1, reg_bak2;
  82   1      
  83   1      #if AutoTune_Debug == ENABLE
              printf("01_AutoTune\n");        //150526 george
              #endif
  86   1      
  87   1      //ResetWDTimer();                               //150526 george
  88   1          if (!IsAutoTuneValid()) {
  89   2              return FALSE;
  90   2          }                                                                                                                                                                                                                   
  91   1      
  92   1          ucAutoPct = 4;
  93   1      
  94   1          reg_bak1 = SC_JITTER_CTRL;
  95   1          reg_bak2 = SC_VI_AUTO_CTRL;
  96   1      
  97   1          SC_JITTER_CTRL = 0x00;
  98   1          if ((SC_ADC_MID_CH_SEL & 0x07) == YPBPR_CLAMP) {
  99   2              SC_VI_AUTO_CTRL |= BIT7;
 100   2          }
 101   1          else {
 102   2              SC_VI_AUTO_CTRL &= ~BIT7;
 103   2          }
 104   1      
 105   1          bIsNonFullScreen = FALSE;
 106   1          bAbortAutoTune = FALSE;
 107   1          if (AutoPosition() == FALSE) {
 108   2              SC_JITTER_CTRL = reg_bak1;
 109   2              SC_VI_AUTO_CTRL = reg_bak2;
 110   2              AutoTuneComplete();
 111   2              return FALSE;
 112   2          }
 113   1          if ((bAbortAutoTune == FALSE) && (bIsNonFullScreen == FALSE)) {
 114   2              if (AutoClock() == FALSE) {
 115   3                  SC_JITTER_CTRL = reg_bak1;
 116   3                  SC_VI_AUTO_CTRL = reg_bak2;
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 6   

 117   3                  AutoTuneComplete();
 118   3                  return FALSE;
 119   3              }
 120   2          }
 121   1      
 122   1          if (ucAutoPct < 100) {   
 123   2              OSDUpdateAutoTune(ucAutoPct++);
 124   2          }
 125   1      
 126   1          if (AutoClockByPhase() == FALSE) {
 127   2              SC_JITTER_CTRL = reg_bak1;
 128   2              SC_VI_AUTO_CTRL = reg_bak2;
 129   2              AutoTuneComplete();
 130   2              return FALSE;
 131   2          }
 132   1      
 133   1          if (AutoPhaseFineTune(ucPhaseRange) == FALSE) {
 134   2              SC_JITTER_CTRL = reg_bak1;
 135   2              SC_VI_AUTO_CTRL = reg_bak2;
 136   2              AutoTuneComplete();
 137   2              return FALSE;
 138   2          }
 139   1      
 140   1          if (AutoPosition() == FALSE) {
 141   2              SC_JITTER_CTRL = reg_bak1;
 142   2              SC_VI_AUTO_CTRL = reg_bak2;
 143   2              AutoTuneComplete();
 144   2              return FALSE;
 145   2          }
 146   1      //ResetWDTimer();                               //150526 george
 147   1          AutoTuneComplete();
 148   1      
 149   1          SC_JITTER_CTRL = reg_bak1;
 150   1          SC_VI_AUTO_CTRL = reg_bak2;
 151   1      
 152   1          return TRUE;
 153   1      }
 154          
 155          /**************************************************************************//**
 156           * Complete the remainder percentage of auto-tune.
 157           ******************************************************************************/
 158          static void AutoTuneComplete(void)
 159          { 
 160   1      
 161   1      #if AutoTune_Debug == ENABLE
              printf("02_AutoTuneComplete\n");        //150526 george
              #endif
 164   1      
 165   1          while (ucAutoPct < 100) {
 166   2              OSDUpdateAutoTune(ucAutoPct++);
 167   2              Sleep(20);
 168   2              if (CheckModeChangeFlag() == TRUE) {
 169   3                  bAbortAutoTune = TRUE;
 170   3                  return ;
 171   3              }
 172   2          }
 173   1          OSDUpdateAutoTune(100);
 174   1      
 175   1      }
 176          
 177          /**************************************************************************//**
 178           * Automatically find image H/V start position.
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 7   

 179           * If system detect mode changed or non-full-screen content, system will stop AutoPosition.
 180           * @return TRUE if system succeed in finding H/V position else FALSE.
 181           ******************************************************************************/
 182          BOOL AutoPosition(void)
 183          {
 184   1      #define MAX_THR_LEVEL 0xA0
 185   1      #define MIN_THR_LEVEL 0x30
 186   1          USHRT temph, tempv, h_active, v_active;
 187   1          USHRT cap_vlen, cap_hwid;
 188   1          UCHAR thr_level, k;
 189   1          BOOL pass_fail;
 190   1      
 191   1      #if AutoTune_Debug == ENABLE
              printf("03_AutoPosition\n");    //150526 george
              #endif
 194   1      
 195   1          cap_vlen = ReadShortScaler(&SC_GI_CAP_VLEN_LO) & 0x07FF;
 196   1          cap_hwid = ReadShortScaler(&SC_GI_CAP_HWID_LO) & 0x0FFF;
 197   1          SetHmask();
 198   1          SC_GI_AUTO_TUNE_CTRL = 0x00;
 199   1      
 200   1          for (thr_level=MIN_THR_LEVEL; thr_level<MAX_THR_LEVEL; thr_level+=0x10) {
 201   2              SC_GI_POS_THR = thr_level; //Red Noise Margin
 202   2              
 203   2              for (k=0; k<5; k++) {
 204   3                  if (MeasureImageSize() == TRUE) {
 205   4                      tempv = GetInputVActLen();
 206   4                      temph = GetInputHActWid();
 207   4                      if ((tempv > 0x100) && (temph > 0x100)) {
 208   5                          pass_fail = TRUE;//pass
 209   5                      }
 210   4                      else {
 211   5                          pass_fail = FALSE;//fail
 212   5                      }
 213   4                  }
 214   3                  else {
 215   4                      return FALSE;
 216   4                  }
 217   3                  if (pass_fail == FALSE) {
 218   4                      break;
 219   4                  }
 220   3              }
 221   2              if (k == 5) {
 222   3                  break;
 223   3              }
 224   2          }
 225   1      
 226   1          if (thr_level > MAX_THR_LEVEL) {
 227   2              return FALSE;
 228   2          }
 229   1      
 230   1          //SC_GI_POS_THR = 0x40; //Red Noise Margin
 231   1          if (MeasureImageSize() == TRUE) {
 232   2              v_active = GetInputVActLen();
 233   2              h_active = GetInputHActWid();
 234   2              if ((abs(h_active-temph) > 5) || (abs(v_active-tempv) > 5)) {
 235   3                  bIsNonFullScreen = TRUE;
 236   3                  CheckImageOutOfScreen();
 237   3                  return FALSE;
 238   3              }
 239   2          }
 240   1          else {
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 8   

 241   2              return FALSE;
 242   2          }
 243   1      
 244   1          temph = GetInputHActBeg();
 245   1          tempv = GetInputVActBeg();
 246   1          if (IsHNonFullScreen(temph,h_active)) {
 247   2              bIsNonFullScreen = TRUE;
 248   2              CheckImageOutOfScreen();
 249   2              return FALSE;
 250   2          }
 251   1          SetHP(temph);
 252   1      
 253   1          if (!IsVNonFullScreen(tempv,v_active)){
 254   2          SetVP(tempv);
 255   2          }
 256   1      
 257   1          return TRUE;
 258   1      }
 259          
 260          /**************************************************************************//**
 261           * Check current input content is full-screen or not.
 262           * @return TRUE if content is full-screen else FALSE.
 263           ******************************************************************************/
 264          void CheckImageOutOfScreen(void)
 265          {
 266   1          USHRT h_start, v_start, h_active, v_active;
 267   1          USHRT cap_vlen, cap_hwid, cap_vstart, cap_hstart, ref;
 268   1      
 269   1      #if OTHER_Degub == ENABLE
                      printf("04_CheckImageOutOfScreen\n");   //150526 george
              #endif
 272   1      
 273   1          cap_vlen = ReadShortScaler(&SC_GI_CAP_VLEN_LO) & 0x07FF;
 274   1          cap_hwid = ReadShortScaler(&SC_GI_CAP_HWID_LO) & 0x0FFF;
 275   1          cap_vstart = ReadShortScaler(&SC_GI_CAP_VBEGO_LO) & 0x07FF;
 276   1          cap_hstart = ReadShortScaler(&SC_GI_CAP_HBEG_LO) & 0x0FFF;
 277   1          v_active = GetInputVActLen();
 278   1          h_active = GetInputHActWid();
 279   1          v_start = GetInputVActBeg();
 280   1          h_start = GetInputHActBeg();
 281   1      
 282   1          if ((v_active < cap_vlen) && (v_start < GetInputVTotal())) {//vertical small then screen
 283   2              if (v_start > cap_vstart) {//down
 284   3                  ref = v_active + v_start - cap_vstart;
 285   3                  if (ref > cap_vlen) {
 286   4                      cap_vstart = ref - cap_vlen + cap_vstart;
 287   4                  }
 288   3              }
 289   2              else {//up
 290   3                  cap_vstart = v_start;
 291   3              }
 292   2          }
 293   1          if ((h_active < cap_hwid) && (h_start < GetAngInputHTotal())) {//horizontal small then screen
 294   2              if (h_start > cap_hstart) {//right
 295   3                  ref = h_active + h_start - cap_hstart;
 296   3                  if (ref > cap_hwid) {
 297   4                      cap_hstart = ref - cap_hwid + cap_hstart;
 298   4                  }
 299   3              }
 300   2              else {//left
 301   3                  cap_hstart = h_start;
 302   3              }
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 9   

 303   2          }
 304   1      
 305   1          // Avoid InputTiming.usHStart < Min, make Hstart related operation abnormal, ex: OSD SliderBar overflo
             -w
 306   1          if (cap_hstart < InputTiming.usHStartMin) 
 307   1              cap_hstart = InputTiming.usHStartMin;
 308   1          else if (cap_hstart > InputTiming.usHStartMax)
 309   1              cap_hstart = InputTiming.usHStartMax;
 310   1      
 311   1          SetHP(cap_hstart);
 312   1          SetVP(cap_vstart);
 313   1      
 314   1          InputTiming.usHStart = GetInputHStart();
 315   1          InputTiming.usVStart = GetInputVStart();
 316   1      //    InputTiming.usHStart50 = InputTiming.usHStart;
 317   1      //    InputTiming.usVStart50 = InputTiming.usVStart;
 318   1      
 319   1      }
 320          
 321          /**************************************************************************//**
 322           * Waiting for scaler to complete the image size detection .
 323           * The detection includes H/V start position, width and height.
 324           * The maximum waiting time is 100ms.
 325           * If the time is over 100ms, the function will return FASLE.
 326           * @return TRUE if the detection is completed else FALSE.
 327           ******************************************************************************/
 328          static BOOL MeasureImageSize(void)
 329          {
 330   1          BOOL i;
 331   1          USHRT local_timer;
 332   1      
 333   1      #if AutoTune_Debug == ENABLE
              printf("05_MeasureImageSize\n");        //150526 george
              #endif
 336   1      
 337   1          i = FALSE;
 338   1          SC_GI_AUTO_TUNE_CTRL = 0x41;
 339   1      
 340   1          local_timer = GetTimerTick();
 341   1          do {
 342   2              ResetWDTimer();
 343   2              if (CheckModeChangeFlag() == TRUE) {
 344   3                  break;
 345   3              }
 346   2              if ((SC_GI_AUTO_TUNE_CTRL & BIT0) == 0) {
 347   3                  i = TRUE;
 348   3                  break;
 349   3              }
 350   2          } while ((GetTimerTick()-local_timer) < 100);
 351   1      
 352   1          if (i == FALSE) {
 353   2              bAbortAutoTune = TRUE;
 354   2          }
 355   1          return i;
 356   1      }
 357          
 358          /**************************************************************************//**
 359           * Automatically find the best htotal (HPLL divider)  to the present analog timing.
 360           * If content is not full-screen, the function will return FALSE.
 361           * @return TRUE if the function is completed else FALSE.
 362           ******************************************************************************/
 363          BOOL AutoClock(void)
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 10  

 364          {
 365   1          UCHAR h_difference, i, compare;
 366   1          USHRT h_ref, h_max, h_total, h_active, h_total_bak;
 367   1      
 368   1      #if AutoTune_Debug == ENABLE
               printf("06_AutoClock\n");      //150526 george
              #endif
 371   1      
 372   1          h_ref = ReadShortScaler(&SC_GI_CAP_HWID_LO);
 373   1          h_max = h_ref<< 1 ;
 374   1          //Set H active reference
 375   1          WriteShortScaler(&SC_GI_CLK_REF_LO, h_ref);
 376   1          //Read pll divider
 377   1          h_total = ReadShortScaler(&SC_HSDDS_DIVIDER_LO);
 378   1          h_total_bak = h_total;
 379   1      
 380   1          if (h_total <= h_ref) {
 381   2              h_total = h_ref + 16;
 382   2              SetADCPLL2(h_total);
 383   2          }
 384   1      
 385   1          for (i=0; i<0x20; i++) {  
 386   2              SetHmask();
 387   2              if (MeasureImageSize() == TRUE) {
 388   3                  h_active = GetInputHActWid();
 389   3                  h_difference = SC_GI_CLK_RESULT;
 390   3                  compare = (h_difference & 0xC0) >> 6;
 391   3                  h_difference = h_difference & 0x3F;
 392   3                  if (compare == 0x00) { //h_ref is equal to h_active
 393   4                      break;
 394   4                  }
 395   3                  if (compare == 0x01) { //less than
 396   4                      h_total = h_total + h_difference;
 397   4                      if (h_total > h_max) {
 398   5                          i = 0xFF;
 399   5                          break;
 400   5                      }
 401   4                  }
 402   3                  if (compare > 0x01) { //greater than
 403   4                      h_total = h_total - h_difference;
 404   4                      if (h_total < h_ref) {
 405   5                          i = 0xFF;
 406   5                          break;
 407   5                      }
 408   4                  }
 409   3                  if (CheckADCPLLOutOfRange(h_total) == TRUE) {
 410   4                      i = 0xFF;
 411   4                      break;
 412   4                  }
 413   3                  SetADCPLL2(h_total);
 414   3              }
 415   2              else {
 416   3                  SetADCPLL2(h_total_bak);
 417   3                  return FALSE;
 418   3              }
 419   2          }
 420   1      
 421   1          if (i == 0xFF) {
 422   2              SetADCPLL2(h_total_bak);
 423   2              bIsNonFullScreen = TRUE;
 424   2              return FALSE;
 425   2          }
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 11  

 426   1          else {
 427   2              return TRUE;
 428   2          }
 429   1      
 430   1      }
 431          
 432          /**************************************************************************//**
 433           * Automatically find tune the HPLL phase setting.
 434           * If system detect mode changed, the function will return FALSE.
 435           * @return TRUE if the function is completed else FALSE.
 436           ******************************************************************************/
 437          BOOL AutoPhaseFineTune(UCHAR len)
 438          {
 439   1          UCHAR qq, yy, uu, i, k;
 440   1          ULONG phase_0, phase_1, phase_2, phase_pre3, phase_now3, phase_delta;
 441   1          USHRT local_timer;
 442   1      
 443   1      #if AutoTune_Debug == ENABLE
               printf("07_AutoPhaseFineTune\n");      //150526 george
              #endif
 446   1      
 447   1          phase_1 = 0x00000000; //(i-1)
 448   1          phase_2 = 0x00000000; //(i-2)
 449   1          phase_pre3 = 0x00000000; //(pre sum)->(delta)->(now sum)
 450   1          phase_delta = 0xFFFFFFFF; //(min delta)
 451   1          qq = SC_HPLL_PHASE_CTRL1 & 0x3F;
 452   1          SC_GI_AUTO_TUNE_CTRL = 0x42;
 453   1      
 454   1          for (yy=1; yy<len; yy++) {
 455   2              if (ucAutoPct < 100) {
 456   3                  OSDUpdateAutoTune(ucAutoPct++);
 457   3              }
 458   2      
 459   2              k = 0;
 460   2              local_timer = GetTimerTick();
 461   2              do {
 462   3                  ResetWDTimer();
 463   3                  if (CheckModeChangeFlag() == TRUE) {
 464   4                      bAbortAutoTune = TRUE;
 465   4                      return FALSE;
 466   4                  }
 467   3                  if ((SC_GI_AUTO_TUNE_CTRL & BIT1) == 0) {
 468   4                      k = 1;
 469   4                      break;
 470   4                  }
 471   3              } while ((GetTimerTick()-local_timer) < 100);
 472   2      
 473   2              if (k == 0) {
 474   3                  bAbortAutoTune = TRUE;
 475   3                  return FALSE;
 476   3              }
 477   2              k = (qq + yy) & 0x3F;
 478   2              SetADCPhase(k);
 479   2      
 480   2              SC_GI_AUTO_TUNE_CTRL = 0x42;
 481   2      
 482   2              phase_now3 = ReadShortScaler(&SC_GI_PHS_SDIFF_HI0);
 483   2              phase_now3 <<= 16;
 484   2              phase_now3 += ReadShortScaler(&SC_GI_PHS_SDIFF_LO0);
 485   2              i = (k - 1) & 0x3F;
 486   2      
 487   2              phase_2 = phase_1; //Shift    
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 12  

 488   2              phase_1 = phase_0;
 489   2              phase_0 = phase_now3;
 490   2              phase_now3 = (phase_0>>2) + (phase_1>>1) + (phase_2>>2);
 491   2              if (yy < 4) {
 492   3                  phase_pre3 = phase_now3; //phase_pre3 = phase_now3
 493   3              }
 494   2              else {
 495   3                  if (phase_now3 > phase_pre3) {
 496   4                      phase_pre3 = phase_now3 - phase_pre3;
 497   4                  }
 498   3                  else {
 499   4                      phase_pre3 = phase_pre3 - phase_now3; //phase_pre3 = delta
 500   4                  }
 501   3                  if (phase_pre3 < phase_delta) {
 502   4                      uu = i;           
 503   4                      phase_delta = phase_pre3;
 504   4                  }
 505   3                  phase_pre3 = phase_now3; //phase_pre3 = phase_now3
 506   3              }     
 507   2          }
 508   1          k = (uu - 1) & 0x3F;
 509   1          SetADCPhase(k);
 510   1      
 511   1          return TRUE;
 512   1      }
 513          
 514          /**************************************************************************//**
 515           * Calibrate the ADC offset of R/G/B channels.
 516           * This function will perform simple auto-gain function first then h/w auto-offset.
 517           * @return TRUE if the calibration is succeeded else FALSE.
 518           ******************************************************************************/
 519          BOOL AutoOffset(void)
 520          {
 521   1      #if AutoTune_Debug == ENABLE
              printf("08_AutoOffset\n");      //150526 george
              #endif
 524   1      
 525   1          if (AutoGainCoarse() == TRUE) {
 526   2              return HwAutoOffset();
 527   2          }
 528   1          else {
 529   2              return FALSE;
 530   2          }
 531   1      }
 532          
 533          /**************************************************************************//**
 534           * Calibrate the ADC offset of R/G/B channels by scaler.
 535           * @return TRUE if the calibration is succeeded else FALSE.
 536           ******************************************************************************/
 537          BOOL HwAutoOffset(void)
 538          {
 539   1          USHRT local_timer, totalRGB[3];
 540   1          UCHAR rgb[3], rgbbk[3], k, value;
 541   1      
 542   1      #if PWRSeq_Deug == ENABLE
              printf("09_HwAutoOffset\n");    //150526 george
              #endif
 545   1      
 546   1      #if IS_NT68150_SERIES
                  SC_CAP_SWAP |= BIT5;
              #endif
 549   1      
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 13  

 550   1          rgbbk[0] = GetADCROffset();
 551   1          rgbbk[1] = GetADCGOffset();
 552   1          rgbbk[2] = GetADCBOffset();
 553   1      
 554   1          rgb[0] = 0;
 555   1          rgb[1] = 0;
 556   1          rgb[2] = 0;
 557   1          SetADCROffset(0);
 558   1          SetADCGOffset(0);
 559   1          SetADCBOffset(0);
 560   1      
 561   1      #if IS_NT68750_SERIES// || IS_NT68770_SERIES || IS_NT68850_SERIES || IS_NT68655_SERIES
                  SC_VI_AUTO_CTRL |= BIT5;
              
                  SC_AUTO_OFFSET_TARGET_RED = 0x00;
                  SC_AUTO_OFFSET_TARGET_GREEN = 0x00;
                  SC_AUTO_OFFSET_TARGET_BLUE = 0x00;
              #else
 568   1          SC_AUTO_OFFSET_TARGET_GREEN = 0x00;
 569   1          if ((SC_ADC_MID_CH_SEL & 0x07) == YPBPR_CLAMP) {
 570   2              SC_AUTO_OFFSET_TARGET_RED = 0x80;
 571   2              SC_AUTO_OFFSET_TARGET_BLUE = 0x80;
 572   2          }
 573   1          else {
 574   2              SC_AUTO_OFFSET_TARGET_RED = 0x00;
 575   2              SC_AUTO_OFFSET_TARGET_BLUE = 0x00;
 576   2          }
 577   1      #endif
 578   1      
 579   1          SC_AUTO_OFFSET_CTRL2 = 0x80;
 580   1          SC_AUTO_OFFSET_CTRL3 = 0x03;
 581   1          
 582   1          k = LOOP_COUNTER;
 583   1          totalRGB[0] = 0;
 584   1          totalRGB[1] = 0;
 585   1          totalRGB[2] = 0;
 586   1      
 587   1          local_timer = GetTimerTick();
 588   1          do {
 589   2              ResetWDTimer();
 590   2              Sleep(2);
 591   2              if (CheckModeChangeFlag() == TRUE) {
 592   3                  k = LOOP_COUNTER;
 593   3                  break;
 594   3              }
 595   2              else {
 596   3                  value = GetADCROffset();
 597   3                  if (abs(rgb[0] - value) > ADC_OFFSET_TOLERANCE) {
 598   4                      k = LOOP_COUNTER;
 599   4                  }
 600   3                  rgb[0] = value;
 601   3                  value = GetADCGOffset();
 602   3                  if (abs(rgb[1] - value) > ADC_OFFSET_TOLERANCE) {
 603   4                      k = LOOP_COUNTER;
 604   4                  }
 605   3                  rgb[1] = value;
 606   3                  value = GetADCBOffset();
 607   3                  if (abs(rgb[2] - value) > ADC_OFFSET_TOLERANCE) {
 608   4                      k = LOOP_COUNTER;
 609   4                  }
 610   3                  rgb[2] = value;
 611   3                  if (k == LOOP_COUNTER) {//reset totalRGB[]
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 14  

 612   4                      totalRGB[0] = rgb[0];
 613   4                      totalRGB[1] = rgb[1];
 614   4                      totalRGB[2] = rgb[2];
 615   4                  }
 616   3                  else {//accumulate
 617   4                      totalRGB[0] += rgb[0];
 618   4                      totalRGB[1] += rgb[1];
 619   4                      totalRGB[2] += rgb[2];
 620   4                  }
 621   3                  if (--k == 0) {
 622   4                      rgb[0] = totalRGB[0] / LOOP_COUNTER;
 623   4                      rgb[1] = totalRGB[1] / LOOP_COUNTER;
 624   4                      rgb[2] = totalRGB[2] / LOOP_COUNTER;
 625   4                  }
 626   3              }
 627   2          } while ((k != 0) && ((GetTimerTick() - local_timer) < 300));
 628   1      
 629   1          SC_AUTO_OFFSET_CTRL2 = 0x00;
 630   1          SC_AUTO_OFFSET_CTRL3 = 0x00;
 631   1      
 632   1      #if IS_NT68150_SERIES
                  SC_CAP_SWAP &= ~BIT5;
              #endif
 635   1          if (k != 0) {
 636   2              SetADCROffset(rgbbk[0]);
 637   2              SetADCGOffset(rgbbk[1]);
 638   2              SetADCBOffset(rgbbk[2]);
 639   2              return FALSE;
 640   2          }
 641   1      
 642   1          if ((SC_ADC_MID_CH_SEL & 0x07) == YPBPR_CLAMP) {
 643   2              SetADCROffset(rgb[0]);
 644   2              SetADCGOffset(rgb[1] + ADC_OFFSET_ADJ);
*** ERROR C202 IN LINE 644 OF LIB\AUTOADJ.C: 'ADC_OFFSET_ADJ': undefined identifier
 645   2              SetADCBOffset(rgb[2]);
 646   2          }
 647   1          else {
 648   2              SetADCROffset(rgb[0] + ADC_OFFSET_ADJ);
*** ERROR C202 IN LINE 648 OF LIB\AUTOADJ.C: 'ADC_OFFSET_ADJ': undefined identifier
 649   2              SetADCGOffset(rgb[1] + ADC_OFFSET_ADJ);
*** ERROR C202 IN LINE 649 OF LIB\AUTOADJ.C: 'ADC_OFFSET_ADJ': undefined identifier
 650   2              SetADCBOffset(rgb[2] + ADC_OFFSET_ADJ);
*** ERROR C202 IN LINE 650 OF LIB\AUTOADJ.C: 'ADC_OFFSET_ADJ': undefined identifier
 651   2          }
 652   1      
 653   1          return TRUE;
 654   1      }
 655          
 656          /**************************************************************************//**
 657           * Calibrate the ADC gain of R/G/B channels.
 658           * If we enable ENABLE_HW_AUTOCOLOR, this function will call h/w ADC gain calibration.
 659           * Otherwise, f/w based calibration will be performed.
 660           * @return TRUE if the calibration is succeeded else FALSE.
 661           ******************************************************************************/
 662          BOOL AutoGain(void)
 663          {
 664   1      #if ENABLE_HW_AUTOCOLOR == ON
                  return HWAutoGain();
              #else
 667   1          UCHAR i, j, k, m, n, value, *p, offset, bak[3];
 668   1          USHRT local_timer;
 669   1          ULONG phase_result, temp, basic_level;
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 15  

 670   1          BOOL time;
 671   1      
 672   1      #if AutoTune_Debug == ENABLE
              printf("10_AutoGain\n");        //150526 george
              #endif
 675   1      
 676   1          bak[0] = GetADCRGain();
 677   1          bak[1] = GetADCGGain();
 678   1          bak[2] = GetADCBGain();
 679   1          SC_GAUGE_OFFSET = 0xF8;
 680   1          basic_level = ReadShortScaler(&SC_GI_CAP_VLEN_LO);
 681   1          for (m=0; m<3; m++) {
 682   2              i = 0x001 + m * 3; //1,4,7
 683   2              p = &SC_ADC_CTRL;
 684   2              p += i;
 685   2              offset = *p;
 686   2              for (k=offset; k>7; k=k-8) {
 687   3                  SC_GAUGE_CTRL2 = 0x00;
 688   3                  i = 0x001 + m * 3; //1,4,7
 689   3                  p = &SC_ADC_CTRL;
 690   3                  p += i;
 691   3                  *p = k;
 692   3                  i = 0x80 + (2-m)*0x08;
 693   3                  SC_GAUGE_CTRL2 = i;
 694   3                  time = 0;
 695   3                  local_timer = GetTimerTick();
 696   3                  do {
 697   4                      ResetWDTimer();
 698   4                      if (CheckModeChangeFlag() == TRUE) {
 699   5                          bAbortAutoTune = TRUE;
 700   5                          break;
 701   5                      }
 702   4                      if ((SC_GAUGE_CTRL2 & BIT7) == 0) {
 703   5                          time = 1;
 704   5                          break;
 705   5                      }
 706   4                  } while((GetTimerTick() - local_timer) < 100);
 707   3          
 708   3                  if (time == 0) {
 709   4                      bAbortAutoTune = TRUE;
 710   4                  }
 711   3                  if (bAbortAutoTune == TRUE) {
 712   4                      SetADCRGain(bak[0]);
 713   4                      SetADCGGain(bak[1]);
 714   4                      SetADCBGain(bak[2]);
 715   4                      return FALSE;
 716   4                  }
 717   3      
 718   3                  j = 0;
 719   3                  temp = 0;
 720   3                  for (i=0; i<8; i++) {
 721   4                      SC_GAUGE_AREA_SEL = i;
 722   4                      phase_result = ReadShortScaler(&SC_GAUGE_RESULT_MI);
 723   4                      phase_result <<= 8;
 724   4                      value = SC_GAUGE_RESULT_LO;
 725   4                      phase_result += value;
 726   4                      //printf("phase_result %x = %x %ld\r\n",(USHRT)m,(USHRT)k,(phase_result));
 727   4                      if (phase_result > (basic_level*3)) {
 728   5                          j = 0xFF;
 729   5                          break;
 730   5                      }
 731   4                  }
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 16  

 732   3                  if (j != 0) {
 733   4                      break;
 734   4                  }
 735   3              }
 736   2              if (k == 0) {
 737   3                  bAbortAutoTune = TRUE;
 738   3                  SetADCRGain(bak[0]);
 739   3                  SetADCGGain(bak[1]);
 740   3                  SetADCBGain(bak[2]);
 741   3                  return FALSE;
 742   3              }
 743   2              for (n=0; n<16; n++) {
 744   3                  SC_GAUGE_CTRL2 = 0x00;
 745   3                  i = 0x001 + m * 3; //1,4,7
 746   3                  p = &SC_ADC_CTRL;
 747   3                  p += i;
 748   3                  *p = k-n;
 749   3                  i = 0x80 + (2-m)*0x08;
 750   3                  SC_GAUGE_CTRL2 = i;
 751   3                  time = 0;
 752   3                  local_timer = GetTimerTick();
 753   3                  do {
 754   4                      ResetWDTimer();
 755   4                      if (CheckModeChangeFlag() == TRUE) {
 756   5                          bAbortAutoTune = TRUE;
 757   5                          break;
 758   5                      }
 759   4                      if ((SC_GAUGE_CTRL2 & BIT7) == 0) {
 760   5                          time = 1;
 761   5                          break;
 762   5                      }
 763   4                  } while ((GetTimerTick() - local_timer) < 100);
 764   3          
 765   3                  if (time == 0) {
 766   4                      bAbortAutoTune = TRUE;
 767   4                  }
 768   3                  if (bAbortAutoTune == TRUE) {
 769   4                      SetADCRGain(bak[0]);
 770   4                      SetADCGGain(bak[1]);
 771   4                      SetADCBGain(bak[2]);
 772   4                      return FALSE;
 773   4                  }
 774   3                  j = 0;
 775   3                  temp = 0;
 776   3                  SC_GAUGE_AREA_SEL = 7;
 777   3                  phase_result = ReadShortScaler(&SC_GAUGE_RESULT_MI);
 778   3                  phase_result <<= 8;
 779   3                  value = SC_GAUGE_RESULT_LO;
 780   3                  phase_result += value;
 781   3                  //printf("phase_result %x = %x %ld\r\n",(USHRT)m,(USHRT)n,phase_result);
 782   3                  if (phase_result > (basic_level * 10)) {//80
 783   4                      break;
 784   4                  }
 785   3              }       
 786   2              i = 0x001 + m * 3;  //1,4,7
 787   2              j = k-n;
 788   2              p = &SC_ADC_CTRL;
 789   2              p += i;
 790   2              *p = j;
 791   2              //printf("Gain %x = %x %x\r\n",(USHRT)m,(USHRT)k,(USHRT)j);
 792   2          }
 793   1      
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 17  

 794   1          return TRUE;
 795   1      #endif
 796   1      }
 797          
 798          /**************************************************************************//**
 799           * Calibrate the ADC gain of R/G/B channels by scaler.
 800           * @return TRUE if the calibration is succeeded else FALSE.
 801           ******************************************************************************/
 802          #if ENABLE_SELF_AUTOCOLOR == ON
              BOOL HWAutoGain(void)
              {
                  USHRT local_timer, totalRGB[3];
                  UCHAR rgb[3], rgbbk[3], k, value;
              
              
              #if OTHER_Degub == ENABLE
                      printf("11_HWAutoGain\n");      //150526 george
              #endif
              
              #if IS_NT68150_SERIES
                  SC_CAP_SWAP |= BIT5;
              #endif
              
                  rgbbk[0] = GetADCRGain();
                  rgbbk[1] = GetADCGGain();
                  rgbbk[2] = GetADCBGain();
              
                  SetADCInput(ADC_INPUT_INT_WHITE);
                  SC_ADC_TRIM_CTRL |= BIT7;
              
                  SC_AUTO_GAIN_CTRL2 = 0x71;
                  SC_AUTO_GAIN_CTRL3 = 0xFF;
                  SC_AUTO_GAIN_CTRL4 = 0x00;
              
                  rgb[0] = 0;
                  rgb[1] = 0;
                  rgb[2] = 0;
                  SetADCRGain(0xFF);
                  SetADCGGain(0xFF);
                  SetADCBGain(0xFF);
              
              #if 1
                  SC_AUTO_OFFSET_TARGET_RED = 0xF4;
                  SC_AUTO_OFFSET_TARGET_GREEN = 0xF1;
                  SC_AUTO_OFFSET_TARGET_BLUE = 0xEC;
              #else
                  SC_AUTO_OFFSET_TARGET_RED = 0xF5;
                  SC_AUTO_OFFSET_TARGET_GREEN = 0xF4;
                  SC_AUTO_OFFSET_TARGET_BLUE = 0xF0;
              #endif
              
                  SC_AUTO_OFFSET_CTRL2 = 0x80;
                  SC_AUTO_OFFSET_CTRL3 = 0x03;
                  
                  k = LOOP_COUNTER;
                  totalRGB[0] = 0;
                  totalRGB[1] = 0;
                  totalRGB[2] = 0;
              
                  local_timer = GetTimerTick();
                  do {
                      ResetWDTimer();
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 18  

                      Sleep(2);
                      if (CheckModeChangeFlag() == TRUE) {
                          k = LOOP_COUNTER;
                          break;
                      }
                      else {
                          value = GetADCRGain();
                          if (abs(rgb[0] - value) > ADC_GAIN_TOLERANCE) {
                              k = LOOP_COUNTER;
                          }
                          rgb[0] = value;
                          value = GetADCGGain();
                          if (abs(rgb[1] - value) > ADC_GAIN_TOLERANCE) {
                              k = LOOP_COUNTER;
                          }
                          rgb[1] = value;
                          value = GetADCBGain();
                          if (abs(rgb[2] - value) > ADC_GAIN_TOLERANCE) {
                              k = LOOP_COUNTER;
                          }
                          rgb[2] = value;
                          if (k == LOOP_COUNTER) {//reset totalRGB[]
                              totalRGB[0] = rgb[0];
                              totalRGB[1] = rgb[1];
                              totalRGB[2] = rgb[2];
                          }
                          else {//accumulate
                              totalRGB[0] += rgb[0];
                              totalRGB[1] += rgb[1];
                              totalRGB[2] += rgb[2];
                          }
                          if (--k == 0) {
                              rgb[0] = totalRGB[0] / LOOP_COUNTER;
                              rgb[1] = totalRGB[1] / LOOP_COUNTER;
                              rgb[2] = totalRGB[2] / LOOP_COUNTER;
                          }
                      }
                  } while ((k != 0) && ((GetTimerTick() - local_timer) < 300));
              
                  SC_AUTO_OFFSET_CTRL2 = 0x00;
                  SC_AUTO_OFFSET_CTRL3 = 0x00;
              
                  SC_ADC_TRIM_CTRL &= ~BIT7;
                  SC_AUTO_GAIN_CTRL2 = 0x00;
                  SetADCInput(ADC_INPUT_EXT_RGB);
              #if IS_NT68150_SERIES
                  SC_CAP_SWAP &= ~BIT5;
              #endif
              
                  if (k != 0) {
                      SetADCRGain(rgbbk[0]);
                      SetADCGGain(rgbbk[1]);
                      SetADCBGain(rgbbk[2]);
                      return FALSE;
                  }
              
                  SetADCRGain(rgb[0] + ADC_GAIN_ADJ);
                  SetADCGGain(rgb[1] + ADC_GAIN_ADJ);
                  SetADCBGain(rgb[2] + ADC_GAIN_ADJ);
                  return TRUE;
              }
              #endif
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 19  

 918          
 919          /**************************************************************************//**
 920           * Check we can perform auto-color on the the current input interface or not.
 921           * @return TRUE if the interface is valid else FALSE.
 922           ******************************************************************************/
 923          BOOL IsAutoColorValid(void)
 924          {
 925   1          UCHAR interface = GetCurrInputInterface();
 926   1      
 927   1      #if OTHER_Degub == ENABLE
                      printf("12_IsAutoColorValid\n");        //150526 george
              #endif
 930   1      
 931   1          if ((interface == DIGITAL_INPUT0) ||(interface == DIGITAL_INPUT1) ||(interface == DISPLAY_PORT_INPUT))
             - 
 932   1              {
 933   2               return FALSE;
 934   2              }
 935   1      
 936   1                       return TRUE;
 937   1      }
 938          
 939          /**************************************************************************//**
 940           * Perform auto-color function with external signal.
 941           * @return TRUE if auto-color is succeeded else FALSE.
 942           ******************************************************************************/
 943          BOOL AutoColor(void)
 944          {
 945   1          UCHAR reg_bak1, reg_bak2, rgb[6];
 946   1      
 947   1      #if OTHER_Degub == ENABLE
                      printf("13_AutoColor\n");       //150526 george
              #endif
 950   1      
 951   1          if (!IsAutoColorValid()) 
 952   1              {
 953   2               return FALSE;
 954   2              }
 955   1      
 956   1          reg_bak1 = SC_JITTER_CTRL;
 957   1          reg_bak2 = SC_VI_AUTO_CTRL;
 958   1           
 959   1          SC_JITTER_CTRL = 0x00;
 960   1          SC_VI_AUTO_CTRL &= ~BIT5;
 961   1          
 962   1          bAbortAutoTune = FALSE;
 963   1      
 964   1          //offset
 965   1          rgb[0] = GetADCROffset();
 966   1          rgb[1] = GetADCGOffset();
 967   1          rgb[2] = GetADCBOffset();
 968   1          //gain
 969   1          rgb[3] = GetADCRGain();
 970   1          rgb[4] = GetADCGGain();
 971   1          rgb[5] = GetADCBGain();
 972   1      
 973   1          if (AutoOffset() == TRUE) 
 974   1              {
 975   2               if (AutoGain() == FALSE) 
 976   2                       {
 977   3                               bAbortAutoTune = TRUE;
 978   3                      }
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 20  

 979   2              }
 980   1          else {
 981   2              bAbortAutoTune = TRUE;
 982   2          }
 983   1      
 984   1          if (bAbortAutoTune == TRUE) {
 985   2              //offset
 986   2              SetADCROffset(rgb[0]);
 987   2              SetADCGOffset(rgb[1]);
 988   2              SetADCBOffset(rgb[2]);
 989   2              //gain
 990   2              SetADCRGain(rgb[3]);
 991   2              SetADCGGain(rgb[4]);
 992   2              SetADCBGain(rgb[5]);
 993   2      
 994   2              // We do not have to invoke offset again.
 995   2              //HwAutoOffset();
 996   2              //bAbortAutoTune = TRUE;
 997   2          }
 998   1      #if 0//(ModelName == AOC_e2252Vw && defined(AUO_M215HW01_VB)) || (ModelName == AOC_e2351Fh&&defined(LPL_BM
             -230WF5_TJC1)) || (ModelName==AOC_i2353Ph&&defined(LPL_BM230WF3_SJC1))||(ModelName==Envision_G2465Wgl && defined(CMI_M236
             -H3_LA3))////v31_110803_1530_SYS#4
                  else {
                      SetADCRGain(GetADCRGain() - 5);
                      SetADCGGain(GetADCGGain() - 5);
                      SetADCBGain(GetADCBGain() - 5);
                  }
              #endif
1005   1      
1006   1          SC_JITTER_CTRL = reg_bak1;
1007   1          SC_VI_AUTO_CTRL = reg_bak2;
1008   1          return !bAbortAutoTune;
1009   1      }
1010          
1011          /**************************************************************************//**
1012           * Perform auto-color function with internal white level.
1013           * @return TRUE if auto-color is succeeded else FALSE.
1014           ******************************************************************************/
1015          #if ENABLE_SELF_AUTOCOLOR == ON
              BOOL InternalAutoColor(void)
              {
                  UCHAR reg_bak1, reg_bak2, result;
              
              #if OTHER_Degub == ENABLE
                      printf("14_InternalAutoColor\n");       //150526 george
              #endif
              
                  result = FALSE;
                  reg_bak1 = SC_JITTER_CTRL;
                  reg_bak2 = SC_VI_AUTO_CTRL;
              
                  SC_JITTER_CTRL = 0x00;
                  SC_VI_AUTO_CTRL &= ~BIT5;
              
                  EnableSyncProcFreeRun(TRUE);
                  SetADCInput(ADC_INPUT_INT_GND);
                  if (HwAutoOffset()) {
                      SetADCInput(ADC_INPUT_INT_WHITE);
                      if (HWAutoGain()) {
                          result = TRUE;
                      }
                  }
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 21  

              
                  SetADCInput(ADC_INPUT_EXT_RGB);
                  EnableSyncProcFreeRun(FALSE);
              
                  SC_JITTER_CTRL = reg_bak1;
                  SC_VI_AUTO_CTRL = reg_bak2;
              
                  return result;
              }
              #endif
1049          
1050          /**************************************************************************//**
1051           * Automatically fine tune htotal with best ADC phase.
1052           * @return TRUE if the function is succeeded else FALSE.
1053           ******************************************************************************/
1054          static BOOL AutoClockByPhase(void)
1055          {
1056   1          #define CLOCKFINETUNESTEP 2
1057   1      
1058   1          UCHAR k,templ,temph;
1059   1          USHRT good_dot_clock, poor_dot_clock, htotal;
1060   1          ULONG maximum_delta, value, minimum_delta;
1061   1      
1062   1      #if AutoTune_Debug == ENABLE
              printf("15_AutoClockByPhase\n");        //150526 george    
              #endif
1065   1      
1066   1              htotal = ReadShortScaler(&SC_HSDDS_DIVIDER_LO);
1067   1          good_dot_clock = htotal;
1068   1          poor_dot_clock = htotal;
1069   1          maximum_delta = 0;
1070   1          minimum_delta = 0xFFFFFFFF;
1071   1          htotal -= CLOCKFINETUNESTEP; //2005-05-25 mingyu: reduce fine tune time change to 2 times from 5 times
1072   1          for (k=0; k<(CLOCKFINETUNESTEP+2); k++) {
1073   2              SetADCPLL2(htotal);
1074   2              //WaitSetup(40);
1075   2              value = CheckPhaseData();
1076   2              if (bAbortAutoTune == TRUE)
1077   2                  return FALSE;
1078   2              if (maximum_delta < value) {
1079   3                  good_dot_clock = htotal;
1080   3                  maximum_delta = value;
1081   3                  templ = ucPhaseIndexLo;
1082   3                  temph = ucPhaseIndexHi;
1083   3              }
1084   2              if (minimum_delta > value) {
1085   3                  minimum_delta = value;
1086   3                  poor_dot_clock = htotal;
1087   3              }
1088   2              htotal ++;
1089   2          }
1090   1      
1091   1          htotal = good_dot_clock;
1092   1      
1093   1          if (abs(good_dot_clock - poor_dot_clock) != 1) {
1094   2              htotal &= 0xfffe;
1095   2          }
1096   1      
1097   1          SetADCPLL2(htotal);
1098   1          if (good_dot_clock != htotal) {
1099   2              value = CheckPhaseData();
1100   2              maximum_delta = value;
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 22  

1101   2              templ = ucPhaseIndexLo;
1102   2              temph = ucPhaseIndexHi;
1103   2          }
1104   1      
1105   1          good_dot_clock = ReadShortScaler(&SC_GI_CAP_HWID_LO);
1106   1          poor_dot_clock = ReadShortScaler(&SC_GI_CAP_VLEN_LO);
1107   1          value = (ULONG)good_dot_clock * poor_dot_clock *64; //V028, FIND BEST IN PAT-1
1108   1          //printf("Value=%ld\r\n", Value);
1109   1          //printf("maximum_delta=%ld\r\n", maximum_delta);
1110   1          if (maximum_delta < value) {
1111   2              k = (templ + 24) & 0x3F;
1112   2              ucPhaseRange = 32;
1113   2              //printf("REVERSE 180\r\n");
1114   2          }
1115   1          else {
1116   2              k = (temph - 8) & 0x3F;
1117   2              ucPhaseRange = 16;
1118   2              //printf("FIND BEST PHASE\r\n");
1119   2          }
1120   1          SetADCPhase(k);
1121   1      
1122   1          return TRUE;
1123   1      }
1124          
1125          /**************************************************************************//**
1126           * Get the difference of maximum SOD and minimum SOD.
1127           * @return The difference of maximum SOD and minimum SOD.
1128           ******************************************************************************/
1129          static ULONG CheckPhaseData(void)
1130          {
1131   1          ULONG value, minimum_value, maximum_value;
1132   1          USHRT local_timer;
1133   1          UCHAR phase;
1134   1          BOOL k;
1135   1      
1136   1      #if AutoTune_Debug == ENABLE
              printf("16_CheckPhaseData\n");  //150526 george    
              #endif
1139   1      
1140   1          maximum_value = 0;
1141   1          minimum_value = 0xFFFFFFFF;
1142   1          phase = 0;
1143   1          SetADCPhase(phase);
1144   1      
1145   1          SC_GI_AUTO_TUNE_CTRL = 0x42;
1146   1          for (phase=4; phase<0x42; phase=phase+4) {
1147   2              if (ucAutoPct < 100) {
1148   3                  OSDUpdateAutoTune(ucAutoPct++);
1149   3              }
1150   2              k = 0;
1151   2              local_timer = GetTimerTick();
1152   2              do {
1153   3                  ResetWDTimer();
1154   3                  if (CheckModeChangeFlag() == TRUE) {
1155   4                      bAbortAutoTune = TRUE;
1156   4                      return FALSE;
1157   4                  }
1158   3                  if ((SC_GI_AUTO_TUNE_CTRL & BIT1) == 0) {
1159   4                      k = 1;
1160   4                      break;
1161   4                  }
1162   3              } while ((GetTimerTick()-local_timer) < 100);
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 23  

1163   2              if (k == 0) {
1164   3                  bAbortAutoTune = TRUE;
1165   3                  return FALSE;
1166   3              }
1167   2              SetADCPhase(phase);
1168   2              SC_GI_AUTO_TUNE_CTRL = 0x42;
1169   2              value = ReadShortScaler(&SC_GI_PHS_SDIFF_HI0);
1170   2              value <<= 16;
1171   2              value += ReadShortScaler(&SC_GI_PHS_SDIFF_LO0);
1172   2              //printf("Phase %d = %ld\r\n", (USHRT)(phase), value);
1173   2              //printf("Phase %d = %ld\r\n", (USHRT)(phase-4), value);
1174   2              if (value < minimum_value) {
1175   3                  minimum_value = value;
1176   3                  ucPhaseIndexLo = (phase - 4) & 0x3F;
1177   3              }
1178   2              if (value > maximum_value) {
1179   3                  maximum_value = value;
1180   3                  ucPhaseIndexHi = (phase - 4) & 0x3F;
1181   3              }
1182   2          }
1183   1      
1184   1          value = maximum_value - minimum_value;
1185   1      
1186   1          //printf("usHTotal = %d\r\n",usHTotal);
1187   1          //printf("MaxMin = %ld\r\n",Value);
1188   1      
1189   1          return value;
1190   1      }
1191          
1192          /**************************************************************************//**
1193           * Automatically calibrate the ADC gain by Max/Min function in scaler.
1194           * @return TRUE if the calibration is succeeded else FALSE..
1195           ******************************************************************************/
1196          static BOOL AutoGainCoarse(void)
1197          {
1198   1      #define MAX_WHITE_GAIN  0xF8
1199   1      #define MIN_WHITE_GAIN  0xF0
1200   1      #define ADC_MIN_GAIN    0x08
1201   1      #define ADC_MAX_GAIN    0xF8
1202   1      
1203   1      #if ENABLE_HW_AUTOCOLOR == ON
                  return TRUE;
              #else
1206   1          UCHAR i,k,value,rgb[3],bak[3];
1207   1          USHRT local_timer, temp;
1208   1      
1209   1      #if OTHER_Degub == ENABLE
                      printf("17_AutoGainCoarse\n");  //150526 george
              #endif
1212   1      
1213   1          bak[0] = GetADCRGain();
1214   1          bak[1] = GetADCGGain();
1215   1          bak[2] = GetADCBGain();
1216   1          rgb[0] = GetADCRGain();
1217   1          rgb[1] = GetADCGGain();
1218   1          rgb[2] = GetADCBGain();
1219   1      
1220   1          for (k=0; k<128; k++) {
1221   2              i = 0;
1222   2              local_timer = GetTimerTick();
1223   2              SC_GI_AUTO_TUNE_CTRL = 0x6e;
1224   2              do {
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 24  

1225   3                  ResetWDTimer();
1226   3                  if (CheckModeChangeFlag() == TRUE) {
1227   4                      bAbortAutoTune = TRUE;
1228   4                      break;
1229   4                  }
1230   3                  if ((SC_GI_AUTO_TUNE_CTRL & BIT1) == 0) {
1231   4                      i = 1;
1232   4                      break;
1233   4                  }
1234   3              } while ((GetTimerTick() - local_timer) < 100);
1235   2      
1236   2              if (i == 0) { //timeout
1237   3                  bAbortAutoTune = TRUE;
1238   3              }
1239   2      
1240   2              if (bAbortAutoTune == TRUE) { //timeout or mode change
1241   3                  SetADCRGain(bak[0]);
1242   3                  SetADCGGain(bak[1]);
1243   3                  SetADCBGain(bak[2]);
1244   3                  return FALSE;
1245   3              }
1246   2      
1247   2              //printf("\r\n");
1248   2              //printf("r = %d\r\n", (USHRT)rgb[0]);
1249   2              //printf("g = %d\r\n", (USHRT)rgb[1]);
1250   2              //printf("b = %d\r\n", (USHRT)rgb[2]);
1251   2              i = 0;
1252   2              value = SC_GI_PHS_SDIFF_LO0;
1253   2      
1254   2              // Basic concept of the following formula is
1255   2              //   ADC code is 0x60 when input is 0.5V and gain setting is 0xFF
1256   2              //   ADC code is 0xF0 when input is 0.5V and gain setting is 0x00
1257   2              //   (Those assumptions are always true!)
1258   2              // If the ADC code of 0.5V with specific gain setting is larger than
1259   2              // real input data, it means the input data is too small to meet our
1260   2              // Scaler spec. (0.5V ~ 0.9V white video level)
1261   2              temp = (USHRT)(0xFF-rgb[0]) * (0xF0-0x60) / 0xFF + 0x60;
1262   2      //        printf("R = %d %d\r\n", (USHRT)value, temp);
1263   2              if (value < temp) {
1264   3                  break;
1265   3              }
1266   2      
1267   2              if ((value<MIN_WHITE_GAIN) && (rgb[0]>ADC_MIN_GAIN)) {
1268   3                  rgb[0] -= (MIN_WHITE_GAIN-value);
1269   3                  i = 0xFF;
1270   3              }
1271   2              if ((value>MAX_WHITE_GAIN) && (rgb[0]<ADC_MAX_GAIN)) {
1272   3                  rgb[0] += (value-MAX_WHITE_GAIN);
1273   3                  i = 0xFF;
1274   3              }
1275   2              value = SC_GI_PHS_SDIFF_LO1;
1276   2      
1277   2              temp = (USHRT)(0xFF-rgb[1]) * (0xF0-0x60) / 0xFF + 0x60;
1278   2      //        printf("G = %d %d\r\n", (USHRT)value, temp);
1279   2              if (value < temp) {
1280   3                  break;
1281   3              }
1282   2      
1283   2              if ((value<MIN_WHITE_GAIN) && (rgb[1]>ADC_MIN_GAIN)) {
1284   3                  rgb[1] -= (MIN_WHITE_GAIN-value);
1285   3                  i = 0xFF;
1286   3              }
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 25  

1287   2              if ((value>MAX_WHITE_GAIN) && (rgb[1]<ADC_MAX_GAIN)) {
1288   3                  rgb[1] += (value-MAX_WHITE_GAIN);
1289   3                  i = 0xFF;
1290   3              }
1291   2              value = SC_GI_PHS_SDIFF_HI0;
1292   2      
1293   2              temp = (USHRT)(0xFF-rgb[2]) * (0xF0-0x60) / 0xFF + 0x60;
1294   2      //        printf("B = %d %d\r\n", (USHRT)value, temp);
1295   2              if (value < temp) {
1296   3                  break;
1297   3              }
1298   2      
1299   2              if ((value<MIN_WHITE_GAIN) && (rgb[2]>ADC_MIN_GAIN)) {
1300   3                  rgb[2] -= (MIN_WHITE_GAIN-value);
1301   3                  i = 0xFF;
1302   3              }
1303   2              if ((value>MAX_WHITE_GAIN) && (rgb[2]<ADC_MAX_GAIN)) {
1304   3                  rgb[2] += (value-MAX_WHITE_GAIN);
1305   3                  i = 0xFF;
1306   3              }
1307   2              if (i == 0) {
1308   3                  if ((rgb[0] < ADC_MIN_GAIN) || (rgb[0] > ADC_MAX_GAIN)) {
1309   4                      break;
1310   4                  }
1311   3                  if ((rgb[1] < ADC_MIN_GAIN) || (rgb[1] > ADC_MAX_GAIN)) {
1312   4                      break;
1313   4                  }
1314   3                  if ((rgb[2] < ADC_MIN_GAIN) || (rgb[2] > ADC_MAX_GAIN)) {
1315   4                      break;
1316   4                  }
1317   3                  return TRUE;
1318   3              }
1319   2              else {
1320   3                  SetADCRGain(rgb[0]);
1321   3                  SetADCGGain(rgb[1]);
1322   3                  SetADCBGain(rgb[2]);
1323   3                  //Sleep(10);
1324   3              }
1325   2          }
1326   1          SetADCRGain(bak[0]);
1327   1          SetADCGGain(bak[1]);
1328   1          SetADCBGain(bak[2]);
1329   1          bAbortAutoTune = TRUE;
1330   1      
1331   1          return FALSE;
1332   1      #endif
1333   1      }
1334          
1335          /**************************************************************************//**
1336           * Set horizontal mask to mask the coupling noise from HSync.
1337           ******************************************************************************/
1338          void SetHmask(void)
1339          {
1340   1      #define ADC_PIPE_DELAY    0x08
1341   1      #define HSYNC_LOCK_DELAY  0x18
1342   1      
1343   1          UCHAR sw;
1344   1          USHRT input_active_width, htotal, hposition, hw, mask;
1345   1          float temp;
1346   1      
1347   1      #if PWRSeq_Deug == ENABLE
               printf("18_SetHmask\n");       //150526 george
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 26  

              #endif
1350   1      
1351   1          sw = SC_INPUT_SELECT & 0x03;
1352   1          if (sw > 0x01) {//DVI
1353   2              SC_GI_HMASK_BEG = 1;  // AutoPosition Pixel mask -> H
1354   2              SC_GI_HMASK_END = 0;  // AutoPosition Pixel mask -> H
1355   2              SC_GI_VMASK_BEG = 0;
1356   2              SC_GI_VMASK_END = 0;
1357   2          }
1358   1          else {
1359   2              /*
1360   2              SC_GI_HMASK_BEG = 0x10;  // AutoPosition Pixel mask -> H
1361   2              SC_GI_HMASK_END = 0x10;  // AutoPosition Pixel mask -> H
1362   2              SC_GI_VMASK_BEG = 3;
1363   2              SC_GI_VMASK_END = 3;
1364   2              */
1365   2              input_active_width = ReadShortScaler(&SC_GI_CAP_HWID_LO);
1366   2              htotal = ReadShortScaler(&SC_HSDDS_DIVIDER_LO);
1367   2              hposition = ReadShortScaler(&SC_GI_CAP_HBEG_LO);
1368   2              sw = SC_GI_HS_WID + 1;   // Always + 1 to avoid HMask taking no effect to coupling noise.
1369   2              hw = ReadShortScaler(&SC_GI_HCNT_LO) & 0x1FFF;
1370   2              temp = (float)htotal * sw * 8 / hw;
1371   2              mask = (USHRT)temp + (HSYNC_LOCK_DELAY - ADC_PIPE_DELAY);
1372   2              if (mask > 0xFF) {
1373   3                  mask = 0xFF;
1374   3              }
1375   2              hw = htotal - input_active_width - hposition;
1376   2              if (mask > hw) {
1377   3                  mask = hw;
1378   3              }
1379   2              SC_GI_HMASK_BEG = 0;
1380   2              SC_GI_HMASK_END = mask;
1381   2              SC_GI_VMASK_BEG = 0;
1382   2              SC_GI_VMASK_END = 0;
1383   2          }
1384   1      }
1385          
1386          #if (DVI_MODE==DVI_HV_MODE) || (DVI_MODE==DVI_HVDE_MODE)
*** WARNING C322 IN LINE 1386 OF Lib\AutoAdj.c: unknown identifier
*** WARNING C322 IN LINE 1386 OF Lib\AutoAdj.c: unknown identifier
              /**************************************************************************//**
               * Automatically find the H/V start position of content when input is digital timing.
               * @return TRUE if the function is succeeded else FALSE.
               ******************************************************************************/
              BOOL DVIAutoPosition(void)
              {
                  BOOL i;
                  USHRT local_timer;
              
              #if PWRSeq_Deug == ENABLE
               printf("19_DVIAutoPosition\n");        //150526 george
              #endif
              
                  if ((SC_GI_SYNC_CTRL & BIT7) == 0x00) {
                      // DVIAutoPosition is only available under H+V.
                      return FALSE;
                  }
              
                  bAbortAutoTune = 0;
                  SetHmask();
                  SC_GI_POS_THR = 0x40;  // Red Noise Margin
                  SC_GI_AUTO_TUNE_CTRL = 0x00;
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 27  

               
                  SC_GI_AUTO_TUNE_CTRL = 0x11;
                  Sleep(20);
                  i = 0;
                  local_timer = GetTimerTick();
                  do {
                      ResetWDTimer();
                      if (CheckModeChangeFlag() == TRUE) {
                          bAbortAutoTune = TRUE;
                          break;
                      }
                      if ((SC_GI_AUTO_TUNE_CTRL & BIT0) == 0) {
                          i = 1;
                          break;
                      }
                  } while ((GetTimerTick() - local_timer) < 100);
              
                  if (i == 0) {//timeout
                      bAbortAutoTune = TRUE;
                  }
                  if (bAbortAutoTune == TRUE) {
                      return FALSE;
                  }
                  else {
                      WriteShortScaler(&SC_GI_CAP_VBEGE_LO, ReadShortScaler(&SC_GI_POS_VBEGE_LO));
                      WriteShortScaler(&SC_GI_CAP_VBEGO_LO, ReadShortScaler(&SC_GI_POS_VBEGO_LO));
                      WriteShortScaler(&SC_GI_CAP_HBEG_LO, GetInputHActBeg());
                      return TRUE;
                  }
              }
              #endif
1440          
1441          /**************************************************************************//**
1442           * Set htotal (HPLL divider) step by step.
1443           * @param htotal Horizontal pixel count of input timing.
1444           ******************************************************************************/
1445          void SetADCPLL2(USHRT htotal)
1446          {
1447   1          USHRT htotal_end, htotal_begin;
1448   1      
1449   1      #if AutoTune_Debug == ENABLE
              printf("20_SetADCPLL2\n");      //150526 george
              #endif
1452   1      
1453   1          SC_HPLL_PHASE_CTRL &= ~BIT2;
1454   1          htotal_begin = ReadShortScaler(&SC_HSDDS_DIVIDER_LO);
1455   1          htotal_end = htotal;
1456   1          htotal = htotal_begin;
1457   1          do {
1458   2              if (htotal_end != htotal_begin) {
1459   3                  if (htotal_end > htotal_begin) {
1460   4                      htotal += 4;
1461   4                      if (htotal > htotal_end)
1462   4                          htotal = htotal_end;
1463   4                  }
1464   3                  else {
1465   4                      htotal -= 4;
1466   4                      if (htotal < htotal_end)
1467   4                          htotal = htotal_end;
1468   4                  }
1469   3                  WaitDisVSync();
1470   3                  WriteShortScaler(&SC_HSDDS_DIVIDER_LO, htotal);
C51 COMPILER V7.50   AUTOADJ                                                               11/16/2016 14:31:23 PAGE 28  

1471   3      #if IS_NT68661_SERIES || IS_NT68770_SERIES || IS_NT68850_SERIES || IS_NT68655_SERIES || IS_NT68790_SERIES
1472   3      #if ENABLE_SR == ON
                          SetSRHtotal(htotal);
              #endif
1475   3      #endif
1476   3              }
1477   2          } while (htotal != htotal_end);
1478   1      }
1479          
1480          /**************************************************************************//**
1481           * Check the pixel clock is out of scaler spec or not.
1482           * @return TRUE if pixel clock is out of scaler spec else FALSE.
1483           ******************************************************************************/
1484          BOOL CheckADCPLLOutOfRange(USHRT htotal)
1485          {
1486   1      #if PWRSeq_Deug == ENABLE
              printf("21_CheckADCPLLOutOfRange\n");   //150526 george
              #endif
1489   1      
1490   1          if (((ULONG)MAX_ANALONG_PIXEL_CLOCK * 10000) < ((ULONG)GetInputHFreq() * htotal)) {
*** ERROR C202 IN LINE 1490 OF LIB\AUTOADJ.C: 'MAX_ANALONG_PIXEL_CLOCK': undefined identifier
1491   2              return TRUE;
1492   2          }
1493   1          else {
1494   2              return FALSE;
1495   2          }
1496   1      }

C51 COMPILATION COMPLETE.  106 WARNING(S),  11 ERROR(S)
